{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from 'react';\nexport const useWebSocket = (url = 'ws://localhost:8080') => {\n  _s();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [notifications, setNotifications] = useState([]);\n  const [orderUpdates, setOrderUpdates] = useState([]);\n  const [systemStatus, setSystemStatus] = useState(null);\n  const [userActivity, setUserActivity] = useState([]);\n  const reconnectTimeoutRef = useRef(null);\n  const maxReconnectAttempts = 5;\n  const [reconnectAttempts, setReconnectAttempts] = useState(0);\n  useEffect(() => {\n    const connect = () => {\n      try {\n        const ws = new WebSocket(url);\n        ws.onopen = () => {\n          console.log('WebSocket connected');\n          setIsConnected(true);\n          setReconnectAttempts(0);\n\n          // Send authentication/init message\n          ws.send(JSON.stringify({\n            type: 'auth',\n            token: localStorage.getItem('auth_token'),\n            timestamp: new Date().toISOString()\n          }));\n        };\n        ws.onmessage = event => {\n          try {\n            const message = JSON.parse(event.data);\n            handleMessage(message);\n          } catch (error) {\n            console.error('Error parsing WebSocket message:', error);\n          }\n        };\n        ws.onclose = () => {\n          console.log('WebSocket disconnected');\n          setIsConnected(false);\n          setSocket(null);\n\n          // Auto-reconnect with exponential backoff\n          if (reconnectAttempts < maxReconnectAttempts) {\n            const timeout = Math.pow(2, reconnectAttempts) * 1000; // 1s, 2s, 4s, 8s, 16s\n            console.log(`Attempting to reconnect in ${timeout}ms...`);\n            reconnectTimeoutRef.current = setTimeout(() => {\n              setReconnectAttempts(prev => prev + 1);\n              connect();\n            }, timeout);\n          }\n        };\n        ws.onerror = error => {\n          console.error('WebSocket error:', error);\n        };\n        setSocket(ws);\n      } catch (error) {\n        console.error('Error connecting to WebSocket:', error);\n      }\n    };\n    connect();\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (socket) {\n        socket.close();\n      }\n    };\n  }, [url, reconnectAttempts]);\n  const handleMessage = message => {\n    switch (message.type) {\n      case 'notification':\n        const notification = message.data;\n        setNotifications(prev => [notification, ...prev].slice(0, 50)); // Keep only last 50\n\n        // Show browser notification if permission granted\n        if (Notification.permission === 'granted') {\n          new Notification(notification.title, {\n            body: notification.message,\n            icon: '/favicon.ico',\n            tag: notification.id\n          });\n        }\n        break;\n      case 'order_update':\n        const orderUpdate = message.data;\n        setOrderUpdates(prev => [orderUpdate, ...prev].slice(0, 100)); // Keep only last 100\n\n        // Also add as notification\n        const orderNotification = {\n          id: `order_${orderUpdate.orderId}_${Date.now()}`,\n          title: 'Aggiornamento Ordine',\n          message: `Ordine ${orderUpdate.orderId.substring(0, 8)}... - Status: ${orderUpdate.status}`,\n          type: orderUpdate.status === 'completed' ? 'success' : orderUpdate.status === 'failed' ? 'error' : 'info',\n          timestamp: orderUpdate.timestamp,\n          orderId: orderUpdate.orderId,\n          userId: orderUpdate.userId\n        };\n        setNotifications(prev => [orderNotification, ...prev]);\n        break;\n      case 'system_status':\n        const status = message.data;\n        setSystemStatus(status);\n        break;\n      case 'user_activity':\n        const activity = message.data;\n        setUserActivity(prev => [activity, ...prev].slice(0, 200)); // Keep only last 200\n        break;\n      default:\n        console.log('Unknown message type:', message.type);\n    }\n  };\n  const sendMessage = message => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({\n        ...message,\n        timestamp: new Date().toISOString()\n      }));\n    } else {\n      console.warn('WebSocket not connected, cannot send message');\n    }\n  };\n  const clearNotifications = () => {\n    setNotifications([]);\n  };\n  const markNotificationAsRead = id => {\n    setNotifications(prev => prev.map(notif => notif.id === id ? {\n      ...notif,\n      read: true\n    } : notif));\n  };\n  return {\n    socket,\n    isConnected,\n    notifications,\n    orderUpdates,\n    systemStatus,\n    userActivity,\n    sendMessage,\n    clearNotifications,\n    markNotificationAsRead\n  };\n};\n_s(useWebSocket, \"2/ECJkFN+mfuS3ddDAy3T5SuIrk=\");","map":{"version":3,"names":["useState","useEffect","useRef","useWebSocket","url","_s","socket","setSocket","isConnected","setIsConnected","notifications","setNotifications","orderUpdates","setOrderUpdates","systemStatus","setSystemStatus","userActivity","setUserActivity","reconnectTimeoutRef","maxReconnectAttempts","reconnectAttempts","setReconnectAttempts","connect","ws","WebSocket","onopen","console","log","send","JSON","stringify","type","token","localStorage","getItem","timestamp","Date","toISOString","onmessage","event","message","parse","data","handleMessage","error","onclose","timeout","Math","pow","current","setTimeout","prev","onerror","clearTimeout","close","notification","slice","Notification","permission","title","body","icon","tag","id","orderUpdate","orderNotification","orderId","now","substring","status","userId","activity","sendMessage","readyState","OPEN","warn","clearNotifications","markNotificationAsRead","map","notif","read"],"sources":["/Users/samuelebelfiore/Downloads/discord-bot-main/web-dashboard/src/hooks/useWebSocket.ts"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\n\nexport interface WebSocketMessage {\n  type: 'notification' | 'order_update' | 'system_status' | 'user_activity';\n  data: any;\n  timestamp: string;\n}\n\nexport interface NotificationData {\n  id: string;\n  title: string;\n  message: string;\n  type: 'success' | 'warning' | 'error' | 'info';\n  timestamp: string;\n  userId?: string;\n  orderId?: string;\n}\n\nexport interface OrderUpdateData {\n  orderId: string;\n  status: string;\n  timestamp: string;\n  userId: string;\n  username: string;\n  details: {\n    carrier: string;\n    weight: string;\n    tracking?: string;\n  };\n}\n\nexport interface SystemStatusData {\n  status: 'online' | 'maintenance' | 'offline';\n  auraActive: boolean;\n  notificationPollerActive: boolean;\n  activeOrders: number;\n  systemLoad: number;\n}\n\nexport interface UserActivityData {\n  type: 'login' | 'order_created' | 'credits_added' | 'logout';\n  userId: string;\n  username: string;\n  details: any;\n  timestamp: string;\n}\n\ninterface UseWebSocketReturn {\n  socket: WebSocket | null;\n  isConnected: boolean;\n  notifications: NotificationData[];\n  orderUpdates: OrderUpdateData[];\n  systemStatus: SystemStatusData | null;\n  userActivity: UserActivityData[];\n  sendMessage: (message: any) => void;\n  clearNotifications: () => void;\n  markNotificationAsRead: (id: string) => void;\n}\n\nexport const useWebSocket = (url: string = 'ws://localhost:8080'): UseWebSocketReturn => {\n  const [socket, setSocket] = useState<WebSocket | null>(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [notifications, setNotifications] = useState<NotificationData[]>([]);\n  const [orderUpdates, setOrderUpdates] = useState<OrderUpdateData[]>([]);\n  const [systemStatus, setSystemStatus] = useState<SystemStatusData | null>(null);\n  const [userActivity, setUserActivity] = useState<UserActivityData[]>([]);\n  \n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const maxReconnectAttempts = 5;\n  const [reconnectAttempts, setReconnectAttempts] = useState(0);\n\n  useEffect(() => {\n    const connect = () => {\n      try {\n        const ws = new WebSocket(url);\n        \n        ws.onopen = () => {\n          console.log('WebSocket connected');\n          setIsConnected(true);\n          setReconnectAttempts(0);\n          \n          // Send authentication/init message\n          ws.send(JSON.stringify({\n            type: 'auth',\n            token: localStorage.getItem('auth_token'),\n            timestamp: new Date().toISOString()\n          }));\n        };\n\n        ws.onmessage = (event) => {\n          try {\n            const message: WebSocketMessage = JSON.parse(event.data);\n            handleMessage(message);\n          } catch (error) {\n            console.error('Error parsing WebSocket message:', error);\n          }\n        };\n\n        ws.onclose = () => {\n          console.log('WebSocket disconnected');\n          setIsConnected(false);\n          setSocket(null);\n          \n          // Auto-reconnect with exponential backoff\n          if (reconnectAttempts < maxReconnectAttempts) {\n            const timeout = Math.pow(2, reconnectAttempts) * 1000; // 1s, 2s, 4s, 8s, 16s\n            console.log(`Attempting to reconnect in ${timeout}ms...`);\n            \n            reconnectTimeoutRef.current = setTimeout(() => {\n              setReconnectAttempts(prev => prev + 1);\n              connect();\n            }, timeout);\n          }\n        };\n\n        ws.onerror = (error) => {\n          console.error('WebSocket error:', error);\n        };\n\n        setSocket(ws);\n      } catch (error) {\n        console.error('Error connecting to WebSocket:', error);\n      }\n    };\n\n    connect();\n\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (socket) {\n        socket.close();\n      }\n    };\n  }, [url, reconnectAttempts]);\n\n  const handleMessage = (message: WebSocketMessage) => {\n    switch (message.type) {\n      case 'notification':\n        const notification = message.data as NotificationData;\n        setNotifications(prev => [notification, ...prev].slice(0, 50)); // Keep only last 50\n        \n        // Show browser notification if permission granted\n        if (Notification.permission === 'granted') {\n          new Notification(notification.title, {\n            body: notification.message,\n            icon: '/favicon.ico',\n            tag: notification.id\n          });\n        }\n        break;\n\n      case 'order_update':\n        const orderUpdate = message.data as OrderUpdateData;\n        setOrderUpdates(prev => [orderUpdate, ...prev].slice(0, 100)); // Keep only last 100\n        \n        // Also add as notification\n        const orderNotification: NotificationData = {\n          id: `order_${orderUpdate.orderId}_${Date.now()}`,\n          title: 'Aggiornamento Ordine',\n          message: `Ordine ${orderUpdate.orderId.substring(0, 8)}... - Status: ${orderUpdate.status}`,\n          type: orderUpdate.status === 'completed' ? 'success' : \n                orderUpdate.status === 'failed' ? 'error' : 'info',\n          timestamp: orderUpdate.timestamp,\n          orderId: orderUpdate.orderId,\n          userId: orderUpdate.userId\n        };\n        setNotifications(prev => [orderNotification, ...prev]);\n        break;\n\n      case 'system_status':\n        const status = message.data as SystemStatusData;\n        setSystemStatus(status);\n        break;\n\n      case 'user_activity':\n        const activity = message.data as UserActivityData;\n        setUserActivity(prev => [activity, ...prev].slice(0, 200)); // Keep only last 200\n        break;\n\n      default:\n        console.log('Unknown message type:', message.type);\n    }\n  };\n\n  const sendMessage = (message: any) => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({\n        ...message,\n        timestamp: new Date().toISOString()\n      }));\n    } else {\n      console.warn('WebSocket not connected, cannot send message');\n    }\n  };\n\n  const clearNotifications = () => {\n    setNotifications([]);\n  };\n\n  const markNotificationAsRead = (id: string) => {\n    setNotifications(prev => \n      prev.map(notif => \n        notif.id === id \n          ? { ...notif, read: true } \n          : notif\n      )\n    );\n  };\n\n  return {\n    socket,\n    isConnected,\n    notifications,\n    orderUpdates,\n    systemStatus,\n    userActivity,\n    sendMessage,\n    clearNotifications,\n    markNotificationAsRead\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}